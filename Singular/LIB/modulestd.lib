////////////////////////////////////////////////////////////////////////////////
version=" ";  // $Id$
category="Commutative Algebra";
info=" ";

LIB "modstd.lib";

////////////////////////////////////////////////////////////////////////////////

static proc testPrime(int p, def I)
{
    /*
     * test whether a prime p divides the denominator(s)
     * and leading coefficients of generating set of ideal
     */
    int i,j,k;
    def f;
    number num;
    bigint d1,d2,d3;
    if(typeof(I)=="ideal")
    {
        for(i = 1; i <= ncols(I); i++)
        {
            f = cleardenom(I[i]);
            if(f == 0)
            {
                return(0);
            }
            num = leadcoef(I[i])/leadcoef(f);
            d1 = bigint(numerator(num));
            d2 = bigint(denominator(num));
            if( (d1 mod p) == 0)
            {
                return(0);
            }
            if((d2 mod p) == 0)
            {
                return(0);
            }
            
            for(j = size(f); j > 0; j--)
            {
                d3 = bigint(leadcoef(f[j]));
                if( (d3 mod p) == 0)
                {
                    return(0);
                }
            }
        }
        return(1);
    }
    else
    {
        for(i = 1; i <= ncols(I); i++)
        {
            f = cleardenom(I[i]);
            if(f == 0)
            {
                return(0);
            }
            num = leadcoef(I[i])/leadcoef(f);
            d1 = bigint(numerator(num));
            d2 = bigint(denominator(num));
            if( (d1 mod p) == 0)
            {
                return(0);
            }
            if((d2 mod p) == 0)
            {
                return(0);
            }
            for(j = nrows(f); j > 0; j--)
            {
                for(k=1;k<=size(f[j]);k++)
                {
                    d3 = bigint(leadcoef(f[j][k]));
                    if((d3 mod p) == 0)
                    {
                        return(0);
                    }
                }
            }
        }
        return(1);
    }
}

////////////////////////////////////////////////////////////////////////////////
/* return 1 if the number of factors are in the required bound , 0 else */

static proc minpolyTask(poly f,int p)
{
    /*
     * bound for irreducible factor(s) of (f mod p)
     * see testfact()
     */
    int nr,k,ur;
    ur=deg(f);
    list L=factmodp(f,p);
    if(degtest(L[2])==1)
    {
        // now each factor is squarefree
        if(ur<=3)
        {
            return(1);
        }
        else
        {
            nr = testfact(ur);
            k=ncols(L[1]);
            if(nr < k && k < (ur-nr))// set a bound for k
            {
                return(1);
            }
        }
    }
    return(0);
}

////////////////////////////////////////////////////////////////////////////////
/* return 1 if both testPrime(p,J) and minpolyTask(f,p) is true, 0 else */

proc PrimeTestTask(int p, list L)
{
    /* L=list(I), I=J,f; J ideal , f minpoly */
    int sz,nr,dg;
    def J=L[1];
    sz=ncols(J);
    def f=J[sz];
    poly g;
    if(typeof(f)=="vector")
    {
        g = f[1];
    }
    else
    {
        g =f;
    }
    dg=deg(g);
    if(!testPrime(p,J) or !minpolyTask(g,p))
    {
        return(0);
    }
    return(1);
}

////////////////////////////////////////////////////////////////////////////////
/* compute factors of f mod p with multiplicity */

static proc factmodp(poly f, int p)
{
    def R=basering;
    list l=ringlist(R);
    l[1]=p;
    def S=ring(l);
    setring S;
    list L=factorize(imap(R,f),2);
    ideal J=L[1];
    intvec v=L[2];
    list scx=J,v;
    setring R;
    return(imap(S,scx));
    kill S;
}

////////////////////////////////////////////////////////////////////////////////
/* set a bound for number of factors w.r.t degree nr*/

static proc testfact(int nr)
{
    // nr must be greater than 3
    int i;
    if(nr>3 and nr<=5)
    {
        i=1;
    }
    if(nr>5 and nr<=10)
    {
        i=2;
    }
    if(nr>10 and nr<=15)
    {
        i=3;
    }
    if(nr>15 and nr<=20)
    {
        i=4;
    }
    if(nr>20 and nr<=25)
    {
        i=5;
    }
    if(nr>25 and nr<=30)
    {
        i=6;
    }
    if(nr>30)
    {
        i=10;
    }
    return(i);
}

///////////////////////////////////////////////////////////////////////////////
// return 1 if v[i]>1 , 0 else

static proc degtest(intvec v)
{
    for(int j=1;j<=nrows(v);j++)
    {
        if(v[j]>1)
        {
            return(0);
        }
    }
    return(1);
}

////////////////////////////////////////////////////////////////////////////////

static proc chinRm(list m, list ll, list lk,list l1,int uz)
{
    if(typeof(l1[1])=="ideal" or typeof(l1[1])=="poly")
    {
        poly ff,c;
        for(int i=1;i<=uz;i++)
        {
            c = division(l1[i]*ll[i],m[i])[2][1];
            ff = ff + c*lk[i];
        }
        return(ff);
    }
    else
    {
        vector ff,c;
        for(int i=1;i<=uz;i++)
        {
            c = division(l1[i]*ll[i],vector(m[i]))[2][1];
            ff = ff + c*lk[i];
        }
        return(ff);
    }
}

////////////////////////////////////////////////////////////////////////////////

proc chinrempoly(list l,list m)
{
    int i,j,sz,uz, tmp;
    uz = size(l);
    if(typeof(l[1])=="ideal" or typeof(l[1])=="poly")
    {
        sz = ncols(ideal(l[1]));
        tmp = 1;
    }
    else
    {
        sz = ncols(module(l[1]));
    }
    poly f=1;
    for(i=1;i<=uz;i++)
    {
        f=f*m[i];
    }

    list l1,ll,lk,l2;
    poly c,ff;
    for(j=1;j<=uz;j++)
    {
        lk[j]=f/m[j];
        ll[j]=extgcd(lk[j],m[j])[2];
    }

    if(tmp)
    {
        ideal I,J;
        for(i=1;i<=sz;i++)
        {
            for(j=1;j<=uz;j++)
            {
                I = l[j];
                l1[j] = I[i];
            }
            J[i] = chinRm(m,ll,lk,l1,uz);
        }
        return(J);
    }
    else
    {
        module I,J;
        for(i=1;i<=sz;i++)
        {
            for(j=1;j<=uz;j++)
            {
                I = l[j];
                l1[j] = I[i];
            }
            J[i] = chinRm(m,ll,lk,l1,uz);
        }
        return(J);
    }
}
////////////////////////////////////////////////////////////////////////////////

proc check_leadmonom_and_size(list L)
{
    /*
     * compare the size of ideals in the list and 
     * check the corresponding leading monomials
     * size(L)>=2
     */
    def J=L[1];
    int i=size(L);
    int sc=ncols(J);
    int j,k;
    def g=leadmonom(J[1]);
    for(j=1;j<=i;j++)
    {
        if(ncols(L[j])!=sc)
        {
            return(0);
        }
    }
    for(k=2;k<=i;k++)
    {
        for(j=1;j<=sc;j++)
        {
            if(leadmonom(J[j])!=leadmonom(L[k][j]))
            {
                return(0);
            }
        }
    }
    return(1);
}

////////////////////////////////////////////////////////////////////////////////

static proc LiftPolyCRT(def I)
{
    /*
     * compute std for each factor and combine this result
     * to modulo minpoly via CRT for poly over char p>0
     */
    int tr = timer;
    char(basering);
    def sl;
    int u,in,j;
    list LL,Lk,T2;
    if(typeof(I)=="ideal")
    {
        
        ideal J,K,II;
        poly f;
        u=ncols(I);
        J=I[1..u-1];
        f=I[u];
        K=factorize(f,1);
        in=ncols(K);
        for(j=1;j<=in;j++)
        {
            LL[j]=K[j];
            ideal I(j)=J,K[j];
            I(j)=std(I(j));
            if(size(I(j))==1)
            {
                Lk[j]=I(j);
            }
            else
            {
                I(j)[1]=0;
                I(j)=simplify(I(j), 2);
                Lk[j]=I(j);
            }
        }
        if(check_leadmonom_and_size(Lk))
        {
            // apply CRT for polynomials
            II =chinrempoly(Lk,LL),f;
        }
        else
        {
            II=0;
        }
        return(II);
    }
    else
    {
        module J,II;
        vector f;
        u=ncols(I);
        J=I[1..u-1];
        f=I[u];
        poly ff = f[1];
        ideal K=factorize(ff,1);
        in=ncols(K);
        def Ls = basering;
        list l = ringlist(Ls);
        l[1] = list(l[1]) + list(list(l[2][size(l[2])])) +
               list(list(l[3][size(l[3])])) + list(ideal(0));
        l[2] = delete(l[2],size(l[2]));
        l[3] = delete(l[3],size(l[3]));
        def S1 = ring(l);
        setring S1;
        number Num= number(imap(Ls,ff));
        list l = ringlist(S1);
        l[1][4][1] = Num;
        S1 = ring(l);
        setring S1;
        ideal K = imap(Ls,K);
        //list T2;
        def S2;
        module II;
        number Num;
        /* ++++++ if minpoly is irreducible then K = ideal(0) +++ */
        if(size(K)==0)
        {
            //tr=timer;
            module M = std(imap(Ls,J));
            II = normalize(M);
            //timer-tr;
        }
        else
        {
            for(j=1;j<=in;j++)
            {
                LL[j]=K[j];
                Num = number(K[j]);
                T2 = ringlist(S1);
                T2[1][4][1] = Num;
                S2 = ring(T2);
                setring S2;
                tr=timer;
                module M = std(imap(Ls,J));
                timer-tr;
                setring S1;
                Lk[j]= imap(S2,M);
            }

            if(check_leadmonom_and_size(Lk))
            {
                // apply CRT for polynomials
                setring Ls;
                II =chinrempoly(imap(S1,Lk),imap(S1,LL));
                setring S1;
                II = normalize(imap(Ls,II));                
            }
            else
            {
                setring S1;
                II=[0];
            }
        }
        setring Ls;
        return(imap(S1,II));
    }
}


/* test if 'result' is a GB of the input ideal */
proc final_Test(string command, alias list args, def result)
{
    int i;
    list arg = args;
    // modified for module case
    if(typeof(args[1])=="ideal")
    {
        /* test if args[1] is in result */
        attrib(result, "isSB", 1);
        
        for (i = ncols(args[1]); i > 0; i--)
        {
            if (reduce(args[1][i], result, 1) != 0)
            {
                return(0);
            }
        }
        
        /* test if result is a GB */
        ideal G = std(result);
        if (Modstd::reduce_parallel(G, result))
        {
            return(0);
        }
        return(1);
    }
    else
    {
        /* test if args[1] is in result */
        def Ls = basering;
        list l = ringlist(Ls);
        l[1] = list(l[1]) + list(list(l[2][size(l[2])])) +
               list(list(l[3][size(l[3])])) + list(ideal(0));
        l[2] = delete(l[2],size(l[2])); 
        l[3] = delete(l[3],size(l[3]));
        def sL = ring(l);
        kill l;
        setring sL;
        list arg = imap(Ls,arg);
        module arg_s =arg[1];
        list l = ringlist(sL);
        l[1][4][1] = arg_s[ncols(arg_s)][1];
        arg_s = arg_s[1..ncols(arg_s)-1];
        def cL = ring(l);
        setring cL;
        module ar_gs = imap(sL,arg_s);
        def result = imap(Ls,result);
        attrib(result, "isSB", 1);
        
        for (i = ncols(ar_gs); i > 0; i--)
        {
            if (reduce(ar_gs[i], result, 1) != 0)
            { 
                setring Ls;
                return(0);
            }
        }
        
        /* test if result is a GB */
        module G = std(result);
        if (Modstd::reduce_parallel(G, result))
        {
            setring Ls;
            return(0);
        }
        setring Ls;
        return(1);
    }
}

 ////////////////////////////////////////////////////////////////////////////////
 
 proc PtestStd(string command, list args, def result, int p)
 {
     /*
      * let G be std of I which is not yet known whether it is the correct
      *  standard basis. So this procedure does the first test
      */
     def br = basering;
     
     list lbr = ringlist(br);
     if (typeof(lbr[1]) == "int")
     {
         lbr[1] = p;
     }
     else
     {
         lbr[1][1] = p;
     }
     def rp = ring(lbr);
     setring(rp);
     def Ip = imap(br, args)[1];
     
     int u,in,j,i;
     list LL,Lk,T2;
     if(typeof(Ip)!="ideal")
     {
         module J,II;
         vector f;
         u=ncols(Ip);
         J=Ip[1..u-1];
         f=Ip[u];
         poly ff = f[1];
         ideal K=factorize(ff,1);
         in=ncols(K);
         def Ls = basering;
         list l = ringlist(Ls);
         l[1] = list(l[1]) + list(list(l[2][size(l[2])])) +
                list(list(l[3][size(l[3])]))+list(ideal(0));
         l[2] = delete(l[2],size(l[2]));
         l[3] = delete(l[3],size(l[3]));
         def S1 = ring(l);
         setring S1;
         number Num= number(imap(Ls,ff));
         list l = ringlist(S1);
         l[1][4][1] = Num;
         S1 = ring(l);
         setring S1;
         ideal K = imap(Ls,K);
         module Jp = imap(Ls,J);
         def S2;
         module Ip;
         number Num;
         /* ++++++ if the minpoly is irreducible then K = ideal(0) +++ */
         if(size(K)==0)
         {
             module M = std(Jp);
             Ip = normalize(M);
             //return_nf(M,1,4,0)[2];
             "============= 1 =============";
         }
         else
         {
             for(j=1;j<=ncols(K);j++)
             {
                 LL[j]=K[j];
                 Num = number(K[j]);
                 T2 = ringlist(S1);
                 T2[1][4][1] = Num;
                 S2 = ring(T2);
                 setring S2;
                 module M = std(imap(Ls,J));
                 //return_nf(M,1,4,0)[2];
                 "================ 2 ==============";
                 setring S1;
                 Lk[j]= imap(S2,M);
             }
             if(check_leadmonom_and_size(Lk))
             {
                 // apply CRT for polynomials
                 setring Ls;
                 II =chinrempoly(imap(S1,Lk),imap(S1,LL));
                 setring S1;
                 Ip = normalize(imap(Ls,II));
             }
             else
             {
                 print("here");
                 setring S1;
                 Ip=[0];
             }
         }
         setring S1;
         module Gp = imap(br, result);
         attrib(Gp, "isSB", 1);
         for (i = ncols(Jp); i > 0; i--)
         {
             if (reduce(Jp[i], Gp, 1) != 0)
             {
                 setring(br);
                 return(0);
             }
         }
         
         attrib(Ip,"isSB",1);
         for (i = ncols(Gp); i > 0; i--)
         {
             if (reduce(Gp[i], Ip, 1) != 0)
             {
                 setring(br);
                 return(0);
             }
         }
         setring(br);
         return(1);
     }
     else
     {
         ideal Gp = imap(br, result);
         attrib(Gp, "isSB", 1);
         for (i = ncols(Ip); i > 0; i--)
         {
             if (reduce(Ip[i], Gp, 1) != 0)
             {
                 setring(br);
                 return(0);
             }
         }
         Ip = LiftPolyCRT(Ip);
         attrib(Ip,"isSB",1);
         for (i = ncols(Gp); i > 0; i--)
         {
             if (reduce(Gp[i], Ip, 1) != 0)
             {
                 setring(br);
                 return(0);
             }
         }
         setring(br);
         return(1);
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 
 static proc cleardenomIdeal(def I)
 {
     int t=ncols(I);
     if(size(I)==0)
     {
         return(I);
     }
     else
     {
         for(int i=1;i<=t;i++)
         {
             I[i]=cleardenom(I[i]);
         }
     }
     return(I);
 }

 ////////////////////////////////////////////////////////////////////////////////
 
 static proc modStdparallelized(def I)
 {
     // apply modular.lib
     /* save options */
     intvec opt = option(get);
     option(redSB);
     I = modular("Modulestd::LiftPolyCRT", list(I), PrimeTestTask, Modstd::deleteUnluckyPrimes_std,
     PtestStd, final_Test,536870909);
     attrib(I, "isSB", 1);
     option(set,opt);
     return(I);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 /* main procedure */
 proc nfmodStd(def I, list #)
 {
     list L=#;
     def Rbs=basering;
     poly f;
     int tmp=1;
     if(typeof(I)!="ideal")
     {
         tmp =0;
     }
     int n=nvars(Rbs);
     if(size(I)==0)
     {
         if(!tmp)
         {
             return(module([0]));
         }
         return(ideal(0));
     }
     if(npars(Rbs)==0)
     {
         if(!tmp)
         {
             print("not implemented");
         }
         def J=modStd(I,L);//if algebraic number is in Q
         if(size(#)>0)
         {
             return(cleardenomIdeal(J));
         }
         return(J);
     }
     def S;
     list rl=ringlist(Rbs);
     f=rl[1][4][1];
     if(tmp)
     {
         rl[2][n+1]=rl[1][2][1];
         rl[1]=rl[1][1];
         rl[3][size(rl[3])+1]=rl[3][size(rl[3])];
         rl[3][size(rl[3])-1]=list("dp",1);
         S=ring(rl);
     }
     else
     {
         rl[2] = rl[2] + rl[1][2];
         rl[3][size(rl[3])+1] = rl[1][3][1];
         rl[1] = rl[1][1];
         S = ring(rl);
     }
     setring S;
     poly f=imap(Rbs,f);
     def I=imap(Rbs,I);
     I = simplify(I,2);// eraze the zero generatos
     if(f==0)
     {
         ERROR("minpoly must be non-zero");
     }
     I=I,f;
     def J_I=modStdparallelized(I);
     setring Rbs;
     def J=imap(S,J_I);
     J=simplify(J,2);
     if(size(#)>0)
     {
         return(cleardenomIdeal(J));
     }
     return(J);
 }
 
proc ret_indx(matrix M, int rp)
{
     int i,j,sc;
     for(j=1;j<=ncols(M);j++)
     {
         sc=re_indx(M, rp, j,sc);
         if(j>sc)
         {
             return(sc);
             break;
         }
     }
}
 
proc re_indx(matrix M, int rp, int j, int sc)
{
     int i;
     if(M[1,j]!=0)
     {
         return(sc);
     }
     else
     {
          for(i=2;i<=rp; i++)
          {
             if(M[i,j]!=0)
             {
                 return(sc);
                 break;
             }
          }
          return(j);
     }
}


proc syz_nf(def I, list #)
{
     int i,j, s1,s2,s,k1,k2, i1,i2,i_I,j_I,i_3;
     module sy;
     module N = transpose(I),freemodule(ncols(I));
     N= transpose(N);
     matrix M = modStd(N);// nfmodStd
     i1 = ncols(M);
     i2 = nrows(M);
     i_I = ncols(I);
     j_I = nrows(I);
     i_3 = i2-i_I;// rows of zeros
     j = ret_indx(M,j_I);
     i = i_I;// i is nrows of syz module
     if(j==0)
     {
         i = 0;
     }

     if(i==0)
     {
         if(size(#)!=0)
         {
             matrix T[i_I][i1] = M[(i_3+1)..i2,1..i1];
             matrix G[i_3][i1] = M[1..i_3,1..i1];
             list L = module([0]), module(G), T;
             return(L);
         }
         return(module([0]));
     }
     
     if(size(#)==0)
     {
         matrix V[i][j] = M[(i_3+1)..i2,1..j];
         sy = V;
         return(sy);
     }
     else
     {
             matrix V[i][j] = M[(i_3+1)..i2,1..j];
             matrix T[i_I][i1-j] = M[(i_3+1)..i2,(j+1)..i1];
             matrix G[i_3][i1-j] = M[1..i_3,(j+1)..i1];
             list L = module(V), module(G), T;
             return(L);
     }
}


proc return_nf(matrix M,int nrwsI, int nclsI,list #)
{
    int i,j, s1,s2,s,k1,k2, i1,i2,i_I,j_I,i_3;
     module sy;
     //module N = transpose(I),freemodule(ncols(I));
     //N= transpose(N);
     //matrix M = nfmodStd(N);
     i1 = ncols(M);
     i2 = nrows(M);
     //i_I = ncols(I);
     i_I = nclsI;
     //j_I = nrows(I);
     j_I = nrwsI;
     i_3 = i2-i_I;// rows of zeros
     j = ret_indx(M,j_I);
     i = i_I;// i is nrows of syz module
     if(j==0)
     {
         i = 0;
     }

     if(i==0)
     {
         if(size(#)!=0)
         {
             matrix T[i_I][i1] = M[(i_3+1)..i2,1..i1];
             matrix G[i_3][i1] = M[1..i_3,1..i1];
             list L = module([0]), module(G), T;
             return(L);
         }
         return(module([0]));
     }
     
     if(size(#)==0)
     {
         matrix V[i][j] = M[(i_3+1)..i2,1..j];
         sy = V;
         return(sy);
     }
     else
     {
             matrix V[i][j] = M[(i_3+1)..i2,1..j];
             matrix T[i_I][i1-j] = M[(i_3+1)..i2,(j+1)..i1];
             matrix G[i_3][i1-j] = M[1..i_3,(j+1)..i1];
             list L = module(V), module(G), T;
             return(L);
     }
}
