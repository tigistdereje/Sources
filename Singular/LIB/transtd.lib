///////////////////////////////////////////////////////////////////////////////
version=" ";
category="Commutative Algebra";
info=" ";
LIB "modstd.lib";
LIB "linalg.lib";

static proc collect_coeffs(ideal I)
{
    // return all coef in I w.r.t main variable(s)
    // basering should contain parameter(s) or only main variable(s)
    def G=basering;
    int pr=npars(G);
    list L;
    if(pr==0)
    {
        ERROR("the coefficient field is not rational function field");
    }
    else
    {
        int i,j;
        poly g;
        list  J1,J2;
        number n1,n2,N;
        i=1;
        while(i<=ncols(I))
        {
            g=I[i];
            for(j=1;j<=size(g);j++)
            {
                N=leadcoef(g[j]);
                n1=numerator(N);
                n2=denominator(N);
                J1=J1+list(n1);
                J2=J2+list(n2);
            }
            i++;
        }
        L=J1,J2;
    }
    return(L);
}

static proc Testlist_all(list L)
{
    // basering must contain only main variable(s) i.e. without
    // parameters
    list T;
    ideal I;
    int i,j;
    for(j=1;j<=size(L);j++)
    {
        
        for(i=1;i<=size(L[j]);i++)
        {
            if(deg(L[j][i])!=0)
            {
                I=I+L[j][i];
            }
        }
        T=T+list(I);
        I=0;
    }
    return(T);
}

/* ++++++++++++++++++++  Interpolation +++++++++++++++ */

proc polyInterpolation(list d, list e,list #)
{
    /*  compute a polynomial from a given numeric data
     *  size of d and e must be equal
     * d is list conataining distinct element
     */
    
    /*optional parameters  */
    
    int vr,i;
    int sz=size(#);
    int s_d=size(d);
    poly f,g;
    list l_p,ltd;
    f=e[1];
    g=1;
    int dc,j,dt,td;
    l_p=f,g,d;
    vr =1;
    number s,t;
    if(sz<=2)
    {
        if(sz)
        {
            vr=#[1];
        }
        if(s_d==1)
        {
            return(l_p);
        }
        for(j=2;j<=s_d;j++)
        {
            s = (d[j]-d[1]);
            t = e[j] - number(subst(f,var(vr),d[j]));
            g = g*(var(vr)-d[j-1]);
            for(i=2;i< j;i++)
            {
                s= s*(d[j]-d[i]);
            }
            t = t/s;
            f = f + t*g;
        }
        l_p=f,g,d;
        return(l_p);
    }
    else
    {
        // add points
        vr = #[1];
        ltd = #[4] + d;
        dt = size(#[4]);
        f = #[2];
        g = #[3];
        for(j=1;j<=s_d;j++)
        {
            s = d[j]-ltd[1];
            t = e[j] - number(subst(f,var(vr),d[j]));
            g = g*(var(vr)-ltd[dt+j-1]);
            for(i=2;i < dt+j;i++)
            {
                s= s*(ltd[dt+j]-ltd[i]);
            }
            t = t/s;
            f = f + t*g;
        }
        l_p=f,g,ltd;
        return(l_p);
    }
}

static proc NewtonInterpolationNormal(list d, list e,int vr)
{
    /*  compute a polynomial from given numeric datas 
     *  size of d and e must be equal
     * d is list conataining distinct element
     */
    int i;
    int s_d=size(d);
    poly f=e[1];
    poly g=1;
    number s,t;
    if(s_d==1)
    {
        return(f);
    }
    for(int j=2;j<=s_d;j++)
    {
        s = (d[j]-d[1]);
        t = e[j] - number(subst(f,var(vr),d[j]));
        g = g*(var(vr)-d[j-1]);
        for(i=2;i< j;i++)
        {
            s= s*(d[j]-d[i]);
        }
        t = t/s;
        f = f + t*g;
    }
    return(f);
}

/* +++++++++++++++ chose a shift +++++++++++++++ */

static proc test_the_shift(ideal I, int n, int pa)
{
    // I is coefficients of given ideal in the main procedure
    // n is number of parameters
    
    list sh = chose_a_shift(pa);
    if(size(I)==0)
    {
        return(sh);
    }
    ideal J=Evaluate_givenI(I,sh,1,n);
    int i;
    while(size(J)!=ncols(I))
    {
        i++;
        sh = chose_a_shift(pa);
        J=Evaluate_givenI(I,sh,1,n);
    }
    return(sh);
}

static proc Evaluate_givenI(ideal J,list pr, int i,int n)
{
    int sz=ncols(J);
    int sr=size(pr);
    int k;
    for(int j=1;j<=sz;j++)
    {
        for(k=n+1;k<=n+sr;k++)
        {
            J=subst(J,var(k),number(pr[k-n])**i);
        }
    }
    return(J);
}


proc ran_dom(int a, int b)
{
    int c = random(-1,1);
    if(c >= 0)
    {
       return(random(a,b));
    }
    return(list(random(a,b),-1));
}


static proc chose_a_shift(int pa)
{
    // pa is number of parameters
    list sh,s,h;
    def v = ran_dom(2,15);
    if(typeof(v)=="list")
    {
        h[1] = v[2]*v[1];
        s[1] = v[2]*h[1] +1;
        sh[1] = number(h[1])/s[1];
        for(int i=2;i<=pa;i++)
        {
            h[i]=v[2]*s[i-1];
            s[i]=v[2]*number(h[i])+1;
            sh[i]=number(h[i])/s[i];
        }
    }
    else
    {
        h[1] = v;
        s[1] = h[1] +1;
        sh[1] = number(h[1])/s[1];
        for(int i=2;i<=pa;i++)
        {
            h[i]=s[i-1];
            s[i]=number(h[i])+1;
            sh[i]=number(h[i])/s[i];
        }
    } 
    return(sh);
}

/* +++++++++++++++ chose a random consecutive primes +++++++++++++++ */

static proc Next_prime(int p)
{
    int i;
    while(1)
    {
        i++;
        if((p+i)%2 !=0)
        {
            if(prime(p+i)==p+i)
            {
                return(p+i);
            }
        }
    }
}

static proc chose_prime(int pa, list #)
{
    // return consequetive pa prime(s)
    int p=2;
    int j;
    list L;
    if(size(#)>0)
    {
        p = #[1];
    }
    for(j=1;j<=pa;j++)
    {
        L[j]=p;
        p=Next_prime(p);
    }
    return(L);
}

/* +++++++++++ BerlekampMassey Algorithm +++++++++++++++++++++++ */

static proc reverse_coef(poly f, int i)
{
    poly g;
    for(int j=size(f);j>=1;j--)
    {
        g = g + var(i)**(j-1)*leadcoef(f[j]);
    }
    return(g);
}

static proc rev_coef_new(poly f, int i)
{
    // i the variable position
    matrix M=coeffs(f,var(i));
    int t=nrows(M);
    list  L=number(M[1..t,1]);
    L=L[t..1];
    return(L);
}

/* compute the minimal polynomial of L using Berlekamp/Massey
 * algorithm */

proc BerlekampMassey(list L, int i,list #)
{
    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     * L is stream (sequence), unbounded,  of elements from
       any field 
     * i is variable position 
     * Note that we may not obtain the minimal polynomial
       because the length of the sequence may not be long
       enough so we need to update it this is where we
       need the optional parameter +++++++++++++++*/
    
    list la,Tr;
    int s,j,k,n;
    number De=1;
    number d;
    list Z;
    if(size(#)==0)
    {
        n=size(L);
        poly g(0..n);
        poly B(0..n);
        int l(0..n);
        number D(1..n);
        B(1)=0;
        l(1)=0;
        g(0)=1;
        for(j=1;j<=n;j++)
        {
            s=deg(g(j-1));
            la=rev_coef_new(g(j-1),i);
            d=0;
            for(k=0;k<=s;k++)
            {
                d = d + la[k+1]*number(L[j-s+k]);
            }
            D(j)=d;
            if(D(j)==0)
            {
                if((2*l(j-1)) < j && j>1)
                {
                    return(list(reverse_coef(g(j-1),i),j-1));
                }
                g(j)=g(j-1);
                B(j)=var(i)*B(j-1);
                l(j)=l(j-1);
            }
            else
            {
                if(D(j)!=0 && (2*l(j-1)) < j)
                {
                    // the degree jump;
                    B(j)=g(j-1);
                    g(j)=g(j-1)- (D(j)*var(i)*B(j-1))/De;
                    l(j)=j-l(j-1);
                    De=D(j);
                }
                else
                {
                    if( D(j)!=0 && (2*l(j-1)) >= j)
                    {
                        //coeffients are adjusted 
                        g(j)=g(j-1) - (D(j)*var(i)*B(j-1))/De;
                        B(j)=var(i)*B(j-1);
                        l(j)=l(j-1);
                    }
                }
            }
        }
        Tr=g(n),B(n),l(n),De,n,L;
        return(Tr);
    }
    else
    {
        /*********************************************************************
         ************  update BerlekampMassey procedure *********************/
        n=size(L);
        list M=#[6];
        int ik=n+#[5];
        M[#[5]+1..ik]=L[1..n];
        L=M;
        poly g(0..ik);
        poly B(0..ik);
        int l(0..ik);
        number D(1..ik);
        g(#[5])=#[1];
        B(#[5])=#[2];
        l(#[5])=#[3];
        De=#[4];
        for(j=#[5]+1;j<=ik;j++)
        {
            s=deg(g(j-1));
            la=rev_coef_new(g(j-1),i);
            d=0;
            for(k=0;k<=s;k++)
            {
                d = d + la[k+1]*number(L[j-s+k]);
            }
            D(j)=d;
            if(D(j)==0)
            {
                if((2*l(j-1)) < j && j>1)
                {    
                    return(list(reverse_coef (g(j-1),i),j-1));
                }
                g(j)=g(j-1);
                B(j)=var(i)*B(j-1);
                l(j)=l(j-1);
            }
            else
            {
                if(D(j)!=0 && (2*l(j-1)) < j)
                {
                    B(j)=g(j-1);
                    g(j)=g(j-1)- (D(j)*var(i)*B(j-1))/De;
                    l(j)=j-l(j-1);
                    De=D(j);
                }
                else
                {
                    if( D(j)!=0 && (2*l(j-1)) >= j)
                    {
                        g(j)=g(j-1) - (D(j)*var(i)*B(j-1))/De;
                        B(j)=var(i)*B(j-1);
                        l(j)=l(j-1);
                    }
                }
            }
        }
        Tr=g(ik),B(ik),l(ik),De,ik,L;
        return(Tr);
    }
}

/* ++++++++++++++++++ Sparse Multivariate Interpolation +++++++++++++ */

static proc monom_valuation(bigint B, list L,int n)
{
    /* returns monomial(s) of B w.r.t L see Valua_tion()
     * L is list of primes */
    int nr=size(L);
    poly f=1;
    list l;
    for(int j=n+1;j<=n+nr;j++)
    {
        l = Valua_tion(B,L[j-n]);
        f=f*var(j)**(l[1]);
        B = l[2];
    }
    return(f);
}

static proc Valua_tion(bigint B, bigint S)
{
    // p-adic representation of B returns the maximum exponent
    int j=-1;
    bigint H=1;
    while(1)
    {
        j++;
        H = H*S;
        if((B mod H)!=0)
        {
            return(list(j,(B div (H div S))));
        }
    }
    return(list(0,B));
}

static proc rootsofpoly(poly f,int n)
{
    // f must be linearly factored
    ideal J=factorize(f,1);
    list L;
    for(int i=1;i<=ncols(J);i++)
    {
        L[i]=int(-1*subst(J[i],var(n),0));
    }
    return(L);
}

static proc compute_monom_evaluation(list lroot, list lprime,int n)
{
    /*
     * returns list of monomials and matrix whose values are evaluated 
     * at each monomials w.r.t lprime
     * number of root(s) is equal to the number of terms that we are looking for
     */
    int nr=size(lroot);
    int i,j;
    list L;
    matrix M[nr][nr];
    for(j=1;j<=nr;j++)
    {
        L[j]=monom_valuation(lroot[j],lprime,n);
        for(i=1;i<=nr;i++)
        {
            M[i,j]=bigint(lroot[j])**i;// it should be i
        }
    }
    return(list(L,M));
}

proc SparseInterpolation(poly Br,list La,list lpr,int n)
{
    /* n is the nvars() of the basering
     * Br the minimal polynomial of the sequence La
     */
    int na=size(La);
    
    // compute the roots of f using factorization algorithm      
    
    list Lr=rootsofpoly(Br,n);
    
    // compute monomials and then evaluate them at each lpr[i] for all i 
    
    list F=compute_monom_evaluation(Lr,lpr,n);//monomials to monom
    
    //  compute the coefficients of these monomials          
    
    int nr=nrows(F[2]);
    list la=F[1];// list of monomials
    matrix T[nr][1]=La[1..nr];
    matrix V=inverse(F[2]);// compute inverse of the matrix F[2]
    matrix Z=V*T;// the coefficient ci
    
    // the main procedure ends here
    
    matrix C[1][nr]=la[1..nr];
    poly g=(C*Z)[1,1];
    return(g);
}

/* ++++++++++++++++++++++ univariate rational function reconstruction ++++*/

proc fareypoly(poly f, poly g,list #)
{
    poly r1,r2,r3,t1,t2,q_m,r_m,t_m,q1;
    q_m = 1;
    
    if(f==0)
    {
        return(list(poly(0),poly(1)));
    }
    
    if(2*deg(f)<deg(g))
    { 
        return(list(f,poly(1)));
    }
    number h=number(1)/lu(f);
    r2=f*h;
    r1=g/lu(g);
    t1=0;
    t2=h;
    list ls,l1,l,T;
    
    int i=0;
    
    while(r2!=0)
    {
        i++;
        ls=division(r1,r2);
        r3=r2;
        q1=ls[1][1,1];
        h=number(1)/lu(ls[2][1]);
        r2=ls[2][1]*h;
        r1=r3;
        r3=t2;
        t2=(t1-q1*t2)*h;
        t1=r3;
        
        if( deg(q1) > deg(q_m))
        {
            q_m=q1;
            r_m=r1;
            t_m=t1;
        }
    }
    if(deg(q_m)==1)
    {
        //print("degree of qm is 1");
        return(list(f,poly(1)));//trivial solution
    }
    else
    {
        poly vd = gcd(r_m,t_m);
        if(vd!=1)
        {
            //print("gcd condition is not satisfied");
            t_m = t_m/vd;
            r_m = r_m/vd;
            if(size(#)>0)
            {
                number ut=number(1)/lu(t_m[size(t_m)]);
                return(list(ut*r_m,ut*t_m));//unrealistic solution
            }
            number ut=lu(t_m);
            return(list(r_m/ut,t_m/ut));
        }
        else
        {
            if(size(#)>0)
            {
                number ut=number(1)/lu(t_m[size(t_m)]);
                return(list(ut*r_m,ut*t_m));
            }
            number ut=lu(t_m);
            return(list(r_m/ut,t_m/ut)); 
        }
    }
}


static proc lu(poly f)
{
    if(f!=0)
    { 
        return(leadcoef(f));
    }
    return(1);
}

/* +++++++++++ first lift ++++++++++++++++++++++++++++++++ */

static proc FirstModLift(ideal I,list pr,list shft, int n, ideal cI)
{
    /* first step list 
     * I a given ideal
     * pr list of primes where its size is equal to size of 
       parameters
     * shft is a shift for parameters
     * n is number of variables
     */
    int i,k1,k2;
    def F;
    list T,T1,L1,L2;
    int r_d = random(2,10);
    ideal J;
    F= Add_the_shift_and_evaluate(I,pr,shft,1,r_d,n, cI);
    r_d = F[2];
    J = normalize(modStd(F[1],0));
    //~;
    list M = list(J);
    if(J[1]==1)
    {
        return(list(ideal(1)));
    }
    int ug;
    for(int cZ =1;cZ<=ncols(J);cZ++)
    {
        if(size(J[cZ])>1)
        {
            ug = cZ;
            break;
        }
    }
    if(!ug)
    {
        return(list(J));
    }
    list lev = leadcoef(J[ug][2]);
    list lus = r_d;
    list # =  n;
    
    list L = polyInterpolation(lus,lev,#);
    poly DR,NR;
    poly  G2 = L[2]*(var(n)-L[3][size(L[3])]);
    list fry = fareypoly(L[1],G2,0);
    DR = fry[2];
    NR = fry[1];
    # = list(NR)+list(DR)+list(n)+L;
    F  = Add_the_shift_and_evaluate(I,pr,shft,1,r_d +1,n,cI);
    r_d = F[2];
    J = normalize(modStd(F[1],0));

    M = M + list(J);
    lus = r_d +1;
    int n_z,m_x;
    list tak;
    list M1,M2;
    for(k1=ug;k1<=ncols(J);k1++)
    {
        n_z = size(J[k1]);
        if(n_z>1)
        {
            for(k2=2;k2<=size(J[k1]);k2++)
            {
                if(size(#)<2)
                {
                    lev = list_coef_index(M,k1,k2,size(lus));
                }
                else
                {
                    lev = list_coef_index(list(M[2]), k1, k2,1);
                }
                /* ++++ compute std of a given ideal m_x times */
                T1 = first_check(I,M,pr,shft,n,lus,lev, k1, k2,cI,#);
                if(m_x < T1[4]){ m_x = T1[4];tak = T1[2];}
                L1[k2-1] = T1[3];
                M1[k2-1] = T1[5];
                M = T1[1];
                lus = T1[2];
                # = n;
            }
            L2[k1] = L1;
            M2[k1] = M1;
            M1 = list();
            L1 = list();
        }
    }
    L2 = L2,m_x,tak,M2;
    return(L2);
}

static proc first_check(ideal I, list M,list pr, list shft, int n, list lus,
                 list lev, int k1, int k2,ideal cI, list #)
{
    /* index k1,k2 are lists in M to be interpolated
     * early termination for polyInterpolation
     * list lus distinct values vs evaluation points lev
     */
    ideal Id;
    list Tr,fr,L;
    int ksz,us;
    number ev;
    def F;
    poly G1,G2,DR,NR;
    if(size(#)==1)
    {
        DR=1;
        NR=0;
        for(int j=1;j<=size(lus);j++)
        {
            L = polyInterpolation(lus[j],lev[j],#);
            # = list(n)+L;
            ksz=size(L[3]);
            G1 = L[2];
            G2 = G1*(var(n)-L[3][ksz]);
            fr = fareypoly(L[1],G2,0);
            if(fr[1]==NR and fr[2]==DR)
            {
                return(list(M,lus,list(G1,ksz-1),ksz-1,fr));
            }
            NR = fr[1];
            DR = fr[2];
        }
        while(1)
        {
            NR = fr[1];
            DR = fr[2];
            lus = L[3];
            us = lus[ksz] +1;
            F = Add_the_shift_and_evaluate(I,pr,shft,1,us,n,cI);
            us = F[2];
            Id = normalize(modStd(F[1],0));

            ev = leadcoef(Id[k1][k2]);
            M = M + list(Id);
            # = list(n)+L;
            L = polyInterpolation(list(us),list(ev),#);
            ksz=size(L[3]);
            G1 = L[2];
            G2 = G1*(var(n)-L[3][ksz]);
            fr = fareypoly(L[1],G2,0);
            if(fr[1]==NR and fr[2]==DR)
            {
                return(list(M,L[3],list(G1,ksz-1),ksz-1,fr));
                break;
            }
        }
    }
    else
    {
        NR = #[1];
        DR = #[2];
        # = #[3..size(#)];
        L = polyInterpolation(lus,lev,#);
        ksz=size(L[3]);
        G1 = L[2];
        G2 = G1*(var(n)-L[3][ksz]);
        fr = fareypoly(L[1],G2,0);
        if(fr[1]==NR and fr[2]==DR)
        {
            return(list(M,L[3],list(G1,ksz-1),ksz-1,fr));
        }
        while(1)
        {
            NR = fr[1];
            DR = fr[2];
            lus = L[3];
            us = lus[ksz]+1;
            F = Add_the_shift_and_evaluate(I,pr,shft,1,us,n,cI);
            us = F[2];
            Id = normalize(modStd(F[1],0));

            ev = leadcoef(Id[k1][k2]);
            M = M + list(Id);
            # = list(n)+L;
            L = polyInterpolation(list(us),list(ev),#);
            ksz=size(L[3]);
            G1 = L[2];
            G2 = G1*(var(n)-L[3][ksz]);
            fr = fareypoly(L[1],G2,0);
            if(fr[1]==NR and fr[2]==DR)
            {
                return(list(M,L[3],list(G1,ksz-1),ksz-1,fr));
                break;
            }
        }
    }
}

static proc list_coef_index(list L, int idx1, int idx2,int lmt)
{
    ideal K;
    list lv;
    for(int j=1;j<=lmt;j++)
    {
        K = L[j];
        lv[j] = leadcoef(K[idx1][idx2]);
    }
    return(lv);
}

static proc scalIdeal(ideal I)
{
    int t=ncols(I);
    if(size(I)==0)
    {
        return(I);
    }
    else
    {
        for(int i=1;i<=ncols(I);i++)
        { 
            I[i]=cleardenom(I[i]);
        }
    }
    return(I);
}

/* ++++++++++++++++++ Next lift +++++++++++++++++++++++++++ */

static proc generate_each_time_two_lists(ideal I, list pr, list shft,list Lf,
                          list eta, int m_sz,int in, int fn, int n, ideal cI,list #)
{
    int i=0;
    ideal Id;
    def F;
    list M1,M2;
    int i1,i2,i3;
    for(i1=in;i1<=fn;i1++)
    {
        for(i2=1;i2<=m_sz;i2++)
        {
            F = Add_the_shift_and_evaluate(I,pr,shft,i1,eta[i2],n, cI);
            if(eta[i2]!=F[2])
            {
                print("Bad Evaluation points are used");
            }
            Id = normalize(modStd(F[1],0));

            M1[i2] = Id;
        }
        list l(i1)= arrange_list_first(M1);
        M1 = list();
    }
    M2= l(in..fn);
    if(size(#)==0)
    {
        list Zr = list_all_monom(Id);
    }

    list eta1,cK,lus;
    int m_z;
    poly G,g;
    list l1,l2,l3;
    for(i1=1;i1<=size(M2);i1++)
    {
        l1 = M2[i1];
        for(i3=1;i3<=size(l1);i3++)
        {
            if(typeof(Lf[i3])!="none")
            {
                cK = Lf[i3];
                for(i2=1;i2<=size(cK);i2++)
                {
                    G = cK[i2][1];
                    m_z = cK[i2][2];
                    eta1 = eta[1..m_z];
                    lus = return_coef_indx_wrtk(l1[i3],i2+1,m_z);
                    g = NewtonInterpolationNormal(eta1,lus,n);
                    M1[i2] = fareypoly(g,G,0);
                }
                l2[i3]=M1;
                M1 = list();
            }
        }
        M2[i1]=l2;
        l2 = list();
    }
    if(size(#)==0)
    {
        return(list(M2,Zr));
    }
    return(M2);
}

static proc Evaluate_par(poly f,list shft,int n)
{
    if(deg(f)==0 or f==0)
    {
        return(list(poly(0)));
    }
    int sr=size(shft);
    int k;
    poly g;
    for(k=n+1;k<=n+sr;k++)
    {
        f=subst(f,var(k),var(n)*var(k) + shft[k-n]);
    }
    matrix M = coeffs(f,var(n));
    list L = M[(nrows(M)-1)..1,1];
    return(L);
}

static proc EvaluateatPr(poly f, list prm, int n, int in, int st)
{
    list L;
    poly v;
    int k;
    for(int j=in;j<=st;j++)
    {
        v=subst(f,var(n+1),bigint(prm[1])**j);
        for(k=2;k<=size(prm);k++)
        {
            v=subst(v,var(k+n),bigint(prm[k])**j);
        }
        L= L + list(number(v));
    }
    return(L);
}

static proc Add_poly_list(list lup)
{
    if(size(lup[2])==0)
    {
        return(lup[1]);
    }
    else
    { 
        list l1 = lup[1];
        list l2 = lup[2];
        for(int j=1;j<=size(l1);j++)
        {
            l1[j] = l1[j]+l2[j];
        }
    }
    return(l1);
}

static proc SubList(list L)
{
    if(size(L[2])==0)
    {
        return(L[1]);
    }
    else
    { 
        list l1 = L[1];
        list l2 = L[2];
        for(int j=1;j<=size(l1);j++)
        {
            l1[j] = l1[j]-l2[j];
        }
    }
    return(l1);
}

static proc Add_the_list_farey(list L)
{
    list lst,lyt,Yt,lm;
    int i,j;
    for(j=1;j<=size(L[1]);j++)
    {
        
        lst = L[1];
        if(typeof(lst[j])!="none")
        {
            lyt = lst[j];
            for(i=2;i<=size(L);i++)
            {
                lst = L[i];
                lyt = Add_two_list(lyt,lst[j]);
            }
            Yt[j]= lyt;
            lyt = list();
        }
    }
    return(Yt);
}

static proc Add_list_of_list(list l1,list l2, int m)
{
    list lst,lyt,Yt,lm;
    
    if(size(l1)!=size(l2))
    {
         print("wrong size: sizes of lists do not coincide");
    }
    int i,j;
    for(j=m;j<=size(l1);j++)
    {
        if(typeof(l1[j])!="none")
        {
            for(i=1;i<=size(l1[j]);i++)
            {
                l1[j][i][1] = l1[j][i][1] + l2[j][i][1];
                l1[j][i][2] = l1[j][i][2] + l2[j][i][2];
            }
        }
    }
    return(l1);
}

static proc Two_list_Demir(list l1, list l2)
{
    int im=size(l1);
    int k,i;
    list l,m;
    for(k=1;k<=im;k++)
    {
        for(i=1;i<=2;i++)
        {
            l[i] = l1[k][i] + l2[k][i];
        }
        m[k] = l;
        l = list();
    }
    return(m);
}

static proc Add_two_list(list l1, list l2)
{
    int im=size(l1);
    int k,i;
    list l,m;
    for(k=1;k<=im;k++)
    {
        for(i=1;i<=2;i++)
        {
            if(typeof(l1[k][i])=="poly")
            {
                l[i] = list(l1[k][i]) + list(l2[k][i]);
            }
            else
            {
                l[i] = l1[k][i] + list(l2[k][i]);
            }
        }
        m[k] = l;
        l = list();
    }
    return(m);
}

static proc arrange_list_first(list L)
{
    list T,TT;
    int j,u,l1,l2;
    l1=size(L[1]);
    l2=size(L);
    for(u=1;u<=l1;u++)
    {
        for(j=1;j<=l2;j++)
        {
            TT[j]=L[j][u];
        }
        T[u]=TT;
    }
    return(T);
}

static proc Add_the_shift_and_evaluate(ideal J,list pr, list shft, int i,
                                int us, int n, ideal cI)
{
    // default value of i and us is 1
    // n number of variables
    int k;
    number Nm;
    ideal Ic = cI;
    ideal Jc=J;
    for(k=n+1;k<=n+size(pr);k++)
    {
        Nm = us*(number(pr[k-n])**i)+shft[k-n];
        Jc =subst(Jc,var(k),Nm);
        Ic = subst(Ic, var(k),Nm);
    }
    
    while(size(Ic)!=ncols(Ic))
    {
        us = us +1;
        Ic = cI;
        Jc = J;
        for(k=n+1;k<=n+size(pr);k++)
        {
            Nm = us*(number(pr[k-n])**i)+shft[k-n];
            Jc =subst(Jc,var(k),Nm);
            Ic = subst(Ic, var(k),Nm);
        }
    }
    return(list(Jc,us));
}

static proc return_coef_indx(def I, int i)
{
    list l;
    for(int j=1;j<=size(I);j++)
    {
        l[j] = leadcoef(I[j][i]);
    }
    return(l);
}

static proc return_coef_indx_wrtk(def I, int i, int k)
{
    list l;
    for(int j=1;j<=k;j++)
    {
        l[j] = leadcoef(I[j][i]);
    }
    return(l);
}

/* +++++++++++++++++++ last lift +++++++++++++++++++ */

proc transtd(ideal I, list pr, list shft, int n, ideal cI,list #)
{
    int tmp = size(#);
    int fn=5;
    if(tmp>0)
    {
        fn = #[1];
    }
    kill #;
    def St=basering;
    int nx=nvars(St);
    int nr=nx-size(pr);
    list ly=ringlist(St);
    list L,l1,l3,l4,l5,A1,l2;
    l1=ly[2];
    l2=l1[1..nr];
    L[2]=l2;
    l3=l1[(nr+1)..nx];
    l5=ly[3];
    l4=l5[2];
    A1=ly[1],l3,list(l4),ly[4];
    L[1]=A1;
    l5=delete(l5,2);
    L[3]=l5;
    L[4]=ly[4];
    def Gt=ring(L);
    kill L,l1,l3,l4,l5,A1,l2;
    setring Gt;
    setring St;
    int u_w,i1,i2,i3;
    poly Gn,pn,pl,plm;
    list l1,l2,l3,bp,lup,uM1,uM2,lk1,lk2,lk3,py,l3n;
    ideal J;
    list Lf = FirstModLift(I,pr,shft,n,cI);// generate omega^i, here i=0
    if(size(Lf)==1)
    {
        if(size(Lf[1])>1)
        {
            return(Lf[1]);
        }
        return(ideal(1));
    }
    
    /* the rational function representation for a fixed evaluation point */
    list LF1 = Lf[4];
    /* maximum distinct elements for a homogenizing variable */
    int m_sz = Lf[2];
    /*  distinct element for univariate interpolation */
    list eta = Lf[3];
    /* maximum distinct values for a homogenizing variable */
    eta = eta[1..m_sz];

    Lf = Lf[1];
    int in =2;
    
    /* generate the last two rational functions  to obtain evaluations of 
     * coefficients auxiliary rational functions*/
    list M2 = generate_each_time_two_lists(I, pr, shft, Lf, eta, m_sz,in, fn, n, cI);
    list Zr = M2[2];
    M2 = M2[1];
    M2 = list(LF1) + M2;
    M2 = Add_the_list_farey(M2);
    
    /*================================================================
     **** change the current base ring ==============================*/
    setring Gt;
    list Zr=imap(St,Zr);
    poly Gn;
    ideal J;
    setring St;
    list #;
    while(u_w < size(Zr))
    {
        u_w++;
        if(size(Zr[u_w])>1)
        {
            setring Gt;
            Gn = Zr[u_w][1];
            setring St;
            l1 = M2[u_w];
            for(i1=1;i1<=size(l1);i1++)
            {
                for(i2=1;i2<=2;i2++)
                {
                    for(i3=1;i3<=size(l1[i1][i2][1]);i3++)
                    {
                        l3 = return_coef_indx(l1[i1][i2],i3);
                        l3 = l3,lk1;
                        l3 = SubList(l3);
                        bp = BerlekampMassey(l3,n);
                        if(size(bp)==2)
                        {
                            if(bp[1]==1)
                            {
                                lup = lk3,list();
                            }
                            else
                            {
                                l3 = l3[1..bp[2]];
                                pn = SparseInterpolation(bp[1],l3,pr,n);
                                pl = pn+pl;
                                lup = Evaluate_par(pn, shft, n);
                                lup = lup,lk3;
                            }
                        }
                        else
                        {
                            in = fn + 1;
                            fn = fn + 4;
                            uM1 = generate_each_time_two_lists(I, pr, shft,
                                                Lf, eta, m_sz,in, fn, n,cI,0);
                            uM1 = Add_the_list_farey(uM1);
                            l3 = return_coef_indx(uM1[u_w][i1][i2],i3);
                            if(i3>1)
                            {
                                lk1 = EvaluateatPr(plm, pr, n,in,fn);
                                l3 = l3,lk1;
                                l3 = SubList(l3);
                            }
                            
                            l3n = bp[6];
                            while(1)
                            {
                                # = bp;
                                l3n = l3n + l3;
                                bp = BerlekampMassey(l3,n,#);
                                if(size(bp)==2)
                                {
                                    l3n = l3n[1..bp[2]];
                                    pn = SparseInterpolation(bp[1],l3n,pr,n);
                                    pl = pn + pl;
                                    lup = Evaluate_par(pn,shft,n);
                                    lup = lup,lk3;
                                    break;
                                }
                                else
                                {
                                    in = fn +1;
                                    fn = fn +4;
                                    uM2 = generate_each_time_two_lists(I, pr, shft,
                                                        Lf, eta, m_sz,in, fn, n,cI,0);
                                    uM2 = Add_the_list_farey(uM2);
                                    uM1 = Add_list_of_list(uM1,uM2,u_w);
                                    l3 = return_coef_indx(uM2[u_w][i1][i2],i3);
                                    if(i3>1)
                                    {
                                         lk1 = EvaluateatPr(plm, pr, n,in,fn);
                                         l3 = l3,lk1;
                                         l3 = SubList(l3);
                                    }
                                }
                                
                            }
                            M2 = Add_list_of_list(M2,uM1,u_w);
                            l1 = M2[u_w];
                        }
                        if(i3 < size(l1[i1][i2][1]))
                        {
                            lk3 = Add_poly_list(lup);
                            plm = lk3[1];
                            lk1 = EvaluateatPr(lk3[1], pr, n,1,fn);
                            lk3 = delete(lk3,1);
                        }
                    }
                    py[i2]=pl;
                    pl=0;
                    lk1 = list();
                    lk2 = list();
                    lk3 = list();
                }
                setring Gt;
                list H = imap(St,py);
                Gn = Gn + (H[1]/H[2])*Zr[u_w][i1+1];
                kill H;
                setring St;
            }
        }
        else
        {
            setring Gt;
            Gn = Zr[u_w][1];
            setring St;
        }
        setring Gt;
        Gn = cleardenom(Gn);
        J[u_w] = Gn;
        setring St;
    }
    return(imap(Gt,J));
}

/* +++++++++++++++++ std for one parameter begins here +++++++++++++++++++*/

static proc test_fmodI(poly f,ideal I)
{
    // test whether f in I or not
    attrib(f,"isSB",1);
    for(int i=1;i<=ncols(I);i++)
    {
        if(size(reduce(I,f))!=ncols(I))
        {
            return(0);
        }
    }
    return(1);
}
static proc ChooseprimeIdealsIAnd_ImodgJ(ideal gJ, ideal I,int n1,int nt,
                                         int i_s)
{
    /*
     * gJ is given ideal
     * f is linear with leadcoef 1
     * I is an output from testlist
     * n=nvars(basering);
     * nt number of prime ideals
     */
    int j,ss,si;
    list m,n;
    poly f;
    poly g=1;
    while(1)
    {
        ss++;
        if(i_s==0)
        {
            ERROR("no more points");
        }
        f=var(n1)-i_s;
        if(test_fmodI(f,I)==1)
        {
            j=j+1;
            n=n+list(subst(gJ,var(n1),i_s));
            m[j]=i_s;
        }
        i_s = i_s-1;
        if(j==nt)
        {
            n=n,m;
            return(n);
            break;
        }
    }
}


proc DeleteUnluckyEvaluationPoints(list lus, list m_l, list #)
{
    
     int tk,j,s_z,k;
     list l,m1,m2;
     if(size(#)>0)
     {
         s_z = #[1];
         for(j=1;j<=size(m_l);j++)
         {
            if(size(m_l[j])==s_z)
            {
                k++;
                m2[k] = lus[j];
                m1[k] = m_l[j];
            }
         }
         m_l = m1,m2;
         return(m_l);
     }
     
     l = s_z;
     s_z = ncols(m_l[1]);
     
     for(j=2;j<=size(m_l);j++)
     {
         tk = size(m_l[j]);
         l[j] = tk;
         if(s_z < tk)
         {
            s_z = tk;
         }
     }
     
     for(j=1;j<=size(m_l);j++)
     {
         if(l[j]==s_z)
         {
                k++;
                m2[k] = lus[j];
                m1[k] = m_l[j];
         }
     }
     m_l = m1,m2,s_z;
     return(m_l);
}

proc findluckypoints(ideal I,ideal cI, int nx, int in_value, int r_d, int s_z)
{
      list tl;
      ideal J;
      while(1)
      {
          tl = ChooseprimeIdealsIAnd_ImodgJ(I,cI, nx,in_value,r_d);
          J = std(tl[1][1]);
          r_d = r_d-1;
          if(s_z==ncols(J))
          {
                break;
          }
      }
      J = normalize(J);
      tl[1] = J;
      tl[2] = tl[2][1];
      return(tl);
}

static proc firststdmodp(ideal I,ideal cI, int in_value)
{
    def St=basering;
    int nx=nvars(St);
    int nr=nx-1;
    list ly=ringlist(St);
    list L,l1,l3,l4,l5,A1,l2;
    l1=ly[2];
    l2=l1[1..nr];
    L[2]=l2;
    l3=l1[(nr+1)..nx];
    l5=ly[3];
    l4=l5[2];
    A1=ly[1],l3,list(l4),ly[4];
    L[1]=A1;
    l5=delete(l5,2);
    L[3]=l5;
    L[4]=ly[4];
    def Gt=ring(L);
    kill L,l1,l3,l4,l5,A1,l2;
    setring Gt;
    setring St;
    int i,k1,k2;
    list T,T1,L1,L2,L3;
    int r_d = char(basering)-10;
    list l_1 = ChooseprimeIdealsIAnd_ImodgJ(I,cI, nx,in_value,r_d);//1
    list lus = l_1[2];
    l_1 = l_1[1];
    list m_l;
    m_l[1] = normalize(std(l_1[1]));
    if(m_l[1][1]==1)
    {
        return(list(ideal(1)));
    }
    
    for(i=2;i<=in_value;i++)
    {
        m_l[i] = normalize(std(l_1[i]));//parallelizable
    }
    
    list t_l = DeleteUnluckyEvaluationPoints(lus,m_l);
    int s_ze = t_l[3];
    m_l = t_l[1];
    lus = t_l[2];
    in_value = size(lus);
    int ug;
    
    for(int cZ =1;cZ<=ncols(m_l[1]);cZ++)
    {
        if(size(m_l[1][cZ])>1)
        {
            ug = cZ;
            break;
        }
    }
    if(!ug)
    {
        return(list(m_l[1]));
    }
    
    list lev = list_coef_index(m_l,ug,2,in_value);
    list L = polyInterpolation(lus,lev,nx);
    int ksz=size(L[3]);
    poly G1 = L[2];
    poly G2 = G1*(var(nx)-lus[ksz]);
    poly DR,NR;
    list fry = fareypoly(L[1],G2);
 
    DR = fry[2];
    NR = fry[1];
    list # = list(NR)+list(DR)+list(nx)+L;
    int us = lus[size(lus)]-1;
    list M = m_l;
    l_1 = findluckypoints(I,cI,nx,1,us,s_ze);
 
    ideal J = l_1[1];
    M = M + list(J);
    list Zr = list_all_monom(J);
    lus = l_1[2];
    int n_z,m_x;
    list tak;
    list M1,M2,Fr;
    setring Gt;
    poly g_t;
    list Zr = imap(St,Zr);
    ideal FJ = imap(St,J);
    setring St;
    for(k1=ug;k1<=ncols(J);k1++)
    {
        n_z = size(J[k1]);
        setring Gt;
        g_t = Zr[k1][1];
        setring St;
        if(n_z>1)
        {
            for(k2=2;k2<=size(J[k1]);k2++)
            {
                if(size(#)<2)
                {
                    lev = list_coef_index(M,k1,k2,size(lus));
                }
                else
                {
                    lev = list_coef_index(list(M[size(M)]), k1, k2,1);
                }
                T1 = fareypolyEarlyTermination(I,cI,M,nx,lus,lev, k1, k2,s_ze, #);
                if(m_x < T1[4]){ m_x = T1[4];tak = T1[2];}
                L1[k2-1] = T1[3];
                Fr = T1[5];

                setring Gt;
                list Fr = imap(St,Fr);
                g_t = g_t + (Fr[1]/Fr[2])*Zr[k1][k2];
                kill Fr;
                setring St;
                M = T1[1];
                
                lus = T1[2];
                # = nx;
            }
            L2[k1] = L1;
            L1 = list();
        }
        setring Gt;
        g_t = cleardenom(g_t);
        FJ[k1]= g_t;
        setring St;
    }
    ideal FJ = imap(Gt,FJ);
    FJ = normalize(FJ);
    L2 = FJ,tak,L2,Zr,m_x;
    L2 = L2,s_ze;
    return(L2);
}

static proc list_all_monom(ideal T)
{
    int nr=ncols(T);
    list L,E;
    list l;
    int i,j;
    poly f;
    for(j=1;j<=nr;j++)
    {
        f=T[j];
        for(i=1;i<=size(f);i++)
        {
            l[i]=leadmonom(f[i]);
        }
        L[j]=l;
        l=E;
    }
    return(L);
}

static proc fareypolyEarlyTermination(ideal I, ideal cI, list M, int nx,
                              list lus, list lev, int k1, int k2, int s_ze, list #)
{
    // early termination for farey rational funtion map for polynomials
    //list lus distinct values vs evaluation points lev
    
    ideal Id;
    list Tr,fr,L,l_1;
    int ksz,us;
    number ev;
    poly G1,G2,DR,NR;
    if(size(#)==1)
    {
        nx = #[1];
        L = polyInterpolation(list(lus[1..size(lus)-1]),list(lev[1..size(lev)-1]),#);
        # = list(nx)+L;
        ksz=size(L[3]);
        G1 = L[2];
        G2 = G1*(var(nx)-L[3][ksz]);
        fr = fareypoly(L[1],G2);
 
        NR = fr[1];
        DR = fr[2];
        L = polyInterpolation(lus[size(lus)],lev[size(lev)],#);
        # = list(nx)+L;
        ksz=size(L[3]);
        G1 = L[2];
        G2 = G1*(var(nx)-L[3][ksz]);
        fr = fareypoly(L[1],G2);

        if(fr[1]==NR and fr[2]==DR)
        {
            return(list(M,lus,list(G1,ksz-1),ksz-1,fr));
        }
        
        while(1)
        {
            NR = fr[1];
            DR = fr[2];
            lus = L[3];

            us = lus[ksz]-1;
            l_1 = findluckypoints(I,cI,nx,1,us,s_ze);
            us = l_1[2];
            Id = l_1[1];
            ev = leadcoef(Id[k1][k2]);
            M = M + list(Id);
            L = polyInterpolation(list(us),list(ev),#);
            # = list(nx)+L;
            ksz=size(L[3]);
            G1 = L[2];
            G2 = G1*(var(nx)-L[3][ksz]);
            fr = fareypoly(L[1],G2);
 
            if(fr[1]==NR and fr[2]==DR)
            {
                return(list(M,L[3],list(G1,ksz-1),ksz-1,fr));
                break;
            }
        }
    }
    else
    {
        NR = #[1];
        DR = #[2];
        # = #[3..size(#)];
        L = polyInterpolation(lus,lev,#);
        ksz=size(L[3]);
        G1 = L[2];
        G2 = G1*(var(nx)-L[3][ksz]);
        fr = fareypoly(L[1],G2);
 
        if(fr[1]==NR and fr[2]==DR)
        {
            return(list(M,L[3],list(G1,ksz-1),ksz-1,fr));
        }
        while(1)
        {
            NR = fr[1];
            DR = fr[2];
            lus = L[3];
 
            us = lus[ksz]-1;
            l_1 = findluckypoints(I,cI,nx,1,us,s_ze);
            us = l_1[2];
            Id = l_1[1];
            ev = leadcoef(Id[k1][k2]);
            M = M + list(Id);
            # = list(nx)+L;
            L = polyInterpolation(list(us),list(ev),#);
            ksz=size(L[3]);
            G1 = L[2];
            G2 = G1*(var(nx)-L[3][ksz]);
            fr = fareypoly(L[1],G2);
 
            if(fr[1]==NR and fr[2]==DR)
            {
                return(list(M,L[3],list(G1,ksz-1),ksz-1,fr));
                break;
            }
        }
    }
}


static proc RecoverCoeffsForAFixedData(list stdResults, list distElmnt,
             list maxData, list Zr)
{
    def St=basering;
    int nx=nvars(St);
    int nr=nx-1;
    list ly=ringlist(St);
    list L,l1,l3,l4,l5,A1,l2;
    l1=ly[2];
    l2=l1[1..nr];
    L[2]=l2;
    l3=l1[(nr+1)..nx];
    l5=ly[3];
    l4=l5[2];
    A1=ly[1],l3,list(l4),ly[4];
    L[1]=A1;
    l5=delete(l5,2);
    L[3]=l5;
    L[4]=ly[4];
    def Gt=ring(L);
    kill L,l1,l3,l4,l5,A1,l2;
    setring Gt;
    setring St;
    int i,k1,k2,n_z;
    list M = stdResults;
    ideal J = M[1];
    if(J[1]==1)
    {
        return(list(ideal(1)));
    }
    int ug;
    for(int cZ =1;cZ<=ncols(J);cZ++)
    {
        if(size(J[cZ])>1)
        {
            ug = cZ;
            break;
        }
    }
    if(!ug)
    {
        return(list(J));
    }
    setring Gt;
    poly g_t;
    list Zr = imap(St,Zr);
    ideal FJ = imap(St,J);
    setring St;
    list mD,Fr,lev,lus;
    for(k1=ug;k1<=ncols(J);k1++)
    {
        n_z = size(J[k1]);
        setring Gt;
        g_t = Zr[k1][1];
        setring St;
        if(n_z>1)
        {
            for(k2=2;k2<=size(J[k1]);k2++)
            {
                mD = maxData[k1][k2-1];
                lev = list_coef_index(M,k1,k2,mD[2]);
                lus = distElmnt[1..mD[2]];
                Fr = polyInterpolation(lus, lev,nx);
                Fr[2] = Fr[2]*(var(nx)-lus[mD[2]]);
                Fr = fareypoly(Fr[1],Fr[2]);
                setring Gt;
                list Fr = imap(St,Fr);
                g_t = g_t + (Fr[1]/Fr[2])*Zr[k1][k2];
                kill Fr;
                setring St;
            }
        }
        setring Gt;
        g_t = cleardenom(g_t);
        FJ[k1]= g_t;
        setring St;
    }
    ideal FJ = imap(Gt,FJ);
    return(normalize(FJ));
}

static proc passThePreList(ideal I, ideal cI, list Gm, list lus_m,
  int nva, int ma_x, int s_ze)
{
    
    list m_l;
    int r_d = char(basering)-10;
    if(r_d==0)
    {
        ERROR("wrong no more points");
    }
    list pt;
    m_l = ChooseprimeIdealsIAnd_ImodgJ(I, cI,nva,ma_x,r_d);
    pt=m_l[2];
    m_l = m_l[1];
    for(int i=1;i<=ma_x;i++)
    {
        m_l[i] = normalize(std(m_l[i]));//parallelizable
    }
    list tl = DeleteUnluckyEvaluationPoints(pt,m_l,s_ze);
    m_l = tl[1];
    pt = tl[2];
    return(list(m_l,pt));
}

proc modp_tran(ideal I, ideal cI, int p, int in_value, list #)
{
    def br = basering;
    int st,s_ze;
    list ty = #;

    if(size(#)==0)
    {
        st = 1;
    }
    else
    {
        s_ze = int(ty[1]);
        ty = ty[2];
    }
    
    list lbr = ringlist(br);
    lbr[1] = p;
    def rp = ring(lbr);
    setring(rp);
    def L;
    int nva = nvars(rp);
    if(st)
    {
        L = firststdmodp(imap(br,I),imap(br,cI), in_value);
    }
    else
    {
        list fy = imap(br,ty);
        list distElmnt = fy[1];
        list maxData = fy[2];
        list Zr = fy[3];
        int ma_x = fy[4];
        list tedY = passThePreList(imap(br,I), imap(br,cI), maxData,
                  distElmnt, nva, ma_x,s_ze);
        list stdResults = tedY[1];
        distElmnt = tedY[2];
        L = RecoverCoeffsForAFixedData(stdResults,distElmnt, maxData, Zr);
    }
    setring br;
    return(imap(rp,L));
}

proc tranmodStdOne(ideal I, list #)
{
    /* 
     * note that the number of parameter(s) and variable(s)
     * in the given ideal must be equal to those in the current 
     * base ring
     */ 
    int in_value = 7;
    int tmp, np;
    if(size(#)>0)
    {
        tmp =1;
        if(size(#)>1)
        {
           in_value = #[1];
           np = #[2];
        }
        else
        {
            in_value = #[1];
            np = 1;
        }
    }
    kill #;
    intvec opt = option(get);
    option(redSB);
    def G_t=basering;
    ideal fryoutput;
    int n,pa,kr;
    n=nvars(G_t);
    pa=1;
    list L=collect_coeffs(I);
    I=scalIdeal(I);
    list rl=ringlist(G_t);
    list la=rl[1][2];
    list m=rl[2];
    m[(n+1)..(n+pa)]=la[1..pa];
    rl[2]=m;
    rl[1]=rl[1][1];
    rl[3][size(rl[3])+1]=rl[3][size(rl[3])];
    rl[3][size(rl[3])-1]=list("lp",pa);
    def S_t=ring(rl);
    setring S_t;
    list L=imap(G_t,L);
    ideal I=imap(G_t,I);
    list lc=Testlist_all(L);
    ideal cI = lc[1]+lc[2];
    int pr = 536870909;

    int paSS = prime_test(pr, I);
    list modResult, rL;
    list prm,indices;
    if(paSS)
    {
        prm[1]=pr;
        rL = modp_tran(I,cI,pr,in_value);
    }
    else
    {
        while(1)
        {
            pr = prime(pr-1);
            if(pr<2)
            {
                ERROR("no more primes");
            }
            paSS = prime_test(pr,I);
            if(paSS)
            {
                prm[1]=pr;
                rL = modp_tran(I,cI,pr, in_value);
                break;
            }
        }
    }
 
    bigint N = prm[1];
    int pN =1;
    bigint bN=1;
    pr = prime(pr-1);
    if(pr<2)
    {
        ERROR("no more primes");
    }
    int Testp;
    paSS = prime_test(pr, I);
    if(paSS)
    {
        Testp = pr;
    }
    else
    {
        while(1)
        {
            pr = prime(pr-1);
            if(pr<2)
            {
                ERROR("no more primes");
            }
            paSS = prime_test(pr,I);
            if(paSS)
            {
                Testp = pr;
                break;
            }
        }
    }
    modResult[1] = rL[1];
    list # = modResult[1];
    if(size(#)==1)
    { 
        setring G_t;
        return(imap(S_t,modResult)[1][1]);
    }
    //setring S_t;
    int s_ze = rL[2];
    modResult[1] = #[1];
    # = #[2..size(#)];
    # = s_ze, #;
    pr = Testp;
    ideal JpTest = modp_tran(I,cI,pr,in_value,#);
    int k,i,j;
    j=-1;
    int nprm=10;
    if(tmp)
    {
        nprm = np;
    }
    ideal chiResult, fareyResult;
    while(1)
    {
        j++;
        if(j>1)
        {
            nprm = 2*nprm;
        }
        for(i=1;i<=nprm;i++)
        {
            pr = prime(pr-1);
            if(!(prime_test(pr,I)))
            {
                pr = prime_pass(pr,I);
            }
            prm = prm + list(pr);
            N = N*pr;
            modResult = modResult + list(modp_tran(I,cI,pr,in_value,#));
        }
        // Delete unlucky primes
        indices = deleteUnluckyPrimes_std(modResult);
        for(i = size(indices); i > 0; i--)
        {
            modResult = delete(modResult, indices[i]);
            prm = delete(prm, indices[i]);
        }
        if (pN == 1)
        {
            chiResult = chinrem(modResult, prm);
        }
        else 
        {
            chiResult = chinrem(list(chiResult)+modResult, list(bN)+prm);
        }
        //np=10;
        
        modResult = list();
        bN = bN*N;
        pr = prime(prm[size(prm)]-1);
        prm = list();
        pN = 0;
        N = 1;
        fareyResult = farey(chiResult, bN);
        setring G_t;
        fryoutput = imap(S_t,fareyResult);
        if(!pTest_tran(imap(S_t,JpTest),fryoutput,Testp))
        {
           continue;
        }
        if(finalTest_tran(I,fryoutput))
        {
            break;
        }
        if(j==0){ nprm =10;}
        nprm;
        "================ nprm ============";
        setring S_t;
    }
    setring G_t;
    attrib(fryoutput, "isSB", 1);
    option(set,opt);
    return(fryoutput);
}

/////////////// copied from modstd.lib /////////////////////////////////

static proc deleteUnluckyPrimes_std(list modresults)
{
    int size_modresults = size(modresults);

    /* sort results into categories.
     * each category is represented by three entries:
     * - the corresponding leading ideal
     * - the number of elements
     * - the indices of the elements
     */
    
    list cat;
    ideal L;
    int i, j, size_cat;
    for (i = 1; i <= size_modresults; i++) {
        L = lead(modresults[i]);
        attrib(L, "isSB", 1);
        for (j = 1; j <= size_cat; j++) {
            if (size(L) == size(cat[j][1])
                && size(reduce(L, cat[j][1])) == 0
                && size(reduce(cat[j][1], L)) == 0) {
                cat[j][2] = cat[j][2]+1;
                cat[j][3][cat[j][2]] = i;
                break;
            }
        }
        if (j > size_cat) {
            size_cat++;
            cat[size_cat] = list();
            cat[size_cat][1] = L;
            cat[size_cat][2] = 1;
            cat[size_cat][3] = list(i);
        }
    }

    /* find the biggest categories */
    int cat_max = 1;
    int max = cat[1][2];
    for (i = 2; i <= size_cat; i++) {
        if (cat[i][2] > max) {
            cat_max = i;
            max = cat[i][2];
        }
    }

    /* return all other indices */
    list unluckyIndices;
    for (i = 1; i <= size_cat; i++) {
        if (i != cat_max) {
            unluckyIndices = unluckyIndices + cat[i][3];
        }
    }
    return(unluckyIndices);
}

static proc pTest_tran(ideal JpTest, ideal fareyResult,int Testp)
{
    
    def Gt=basering;
    int nn=nvars(Gt);
    int pr=npars(Gt);
    list rl=ringlist(Gt);
    rl[1][1]=Testp;
    def FG = ring(rl);
    setring FG;
    ideal Jp = imap(Gt,JpTest);
    ideal fry = imap(Gt,fareyResult);
    attrib(fry,"isSB",1);
    attrib(Jp,"isSB",1);
    if(Is_belongs(Jp,fry))
    {
        if(size(reduce(fry,Jp))==0)
        {
            setring Gt;
            return(1);
        }
    }
    setring Gt;
    return(0);
}

static proc prime_test(int p, ideal I)
{
    
    int i,j;
    poly f;
    number num;
    bigint d1,d2,d3;
    for(i = 1; i <= size(I); i++)
    {
        f = cleardenom(I[i]);
        if(f == 0)
        {
            return(0);
        }
        num = leadcoef(I[i])/leadcoef(f);
        d1 =bigint(numerator(num));
        d2 =bigint(denominator(num));
        if((d1 mod p) == 0)
        {
            return(0);
        }
        if((d2 mod p) == 0)
        {
            return(0);
        }
        for(j = size(f); j > 0; j--)
        {
            d3 =bigint(leadcoef(f[j]));
            if((d3 mod p) == 0)
            {
                return(0);
            }
        }
    }
    return(1);
}

static proc prime_pass(int p, ideal I)
{
    //return a prime for which prime_test()==true
    // p must be prime
    int i,q;
    q=p;
    if(q<2)
    {
        ERROR("No more Primes");
    }
    else
    {
        while(1)
        {
            i++;
            if(prime_test(p,I)==1)
            {
                return(q);
            }
            q = prime(q-1);
        }
    }
}

static proc Is_belongs(ideal I, ideal fareyresult)
{
    //return 1 if I included in J otherwise 0
    attrib(fareyresult,"isSB",1);
    int i;
    for(i = ncols(I); i >= 1; i--)
    {
        if(reduce(I[i],fareyresult,1)!= 0)
        {
            return(0);
        }
    }
    return(1);
}

static proc finalTest_tran(ideal I, ideal fareyresult)
{
    //return 1 if I included in fareyresult otherwise 0
    attrib(fareyresult,"isSB",1);
    int i;
    for(i = ncols(I); i >= 1; i--)
    {
        if(reduce(I[i],fareyresult,1)!= 0)
        {
            return(0);
        }
    }
    return(1);
    
    //return 1 if std(fareyresult) included in fareyresult otherwise 0
    attrib(fareyresult,"isSB",1);
    ideal J=std(fareyresult);
    if(size(reduce(J,fareyresult,1))==0)
    {
        return(1);
    }
    return(0);
}

// =============== a procedure for one parameter ends here ==========

// =========== the main procedure for multi parameter begins here ========= 
proc tranmodStd(ideal I,list #)
{
    /*
     * note that the number of parameter(s) and variable(s)
     * in the given ideal must be equal to those in the current
     * basering
     */
    def G_t=basering;
    int n,pa,kr;
    n=nvars(G_t);
    pa=npars(G_t);
    if(size(I)==0)
    {
        return(ideal(0));
    }
    I = simplify(I,2);
    for(int hj=1;hj<=ncols(I);hj++)
    {
        if(deg(I[hj])==0)
        {
            return(ideal(1));
        }
    }
    /*
    if(pa==1)
    {
        return(tranmodStdOne(I));
    }*/
    list L=collect_coeffs(I);
    I=scalIdeal(I);
    list rl=ringlist(G_t);
    list la=rl[1][2];
    list m=rl[2];
    m[(n+1)..(n+pa)]=la[1..pa];
    rl[2]=m;
    rl[1]=rl[1][1];
    rl[3][size(rl[3])+1]=rl[3][size(rl[3])];
    rl[3][size(rl[3])-1]=list("lp",pa);
    def S_t=ring(rl);
    setring S_t;
    list L=imap(G_t,L);
    ideal I=imap(G_t,I);
    list lc=Testlist_all(L);
    ideal cI = lc[1]+lc[2];
    list shft = test_the_shift(lc[1]+lc[2],n,pa);
    shft;
    //shft = 1/2,2/3,3/4,4/5;// this has a problem check R7 H3 shift with the
    // first parameter has some problem shft = 1,2/3,3/4,4/5; works
    //shft = 4/5, 5/6, 6/7,7/8;
    //shft = -5/4,-5/2,-5/3,-5/2;
    //shft = 4/5, 1,1,1;// this shift has a problem with example I12 shift with
    // the second parameter has some problem shft = 4/5, 1/7,1,1; works

    for(int j=1;j<=size(shft);j++)
    {
        cI = subst(cI, var(n+j), var(n+j) + shft[j]);
    }
    
    list pr=chose_prime(pa);
    //pr = 11,13,17,19;
    ideal J = transtd(I,pr,shft,n,cI,#);
    setring G_t;
    ideal J = imap(S_t,J);
    if(finalTest_tran(I,J))
    {
        return(J);
    }
    else
    {
         print("FAIL");
         //imap(S_t,shft);
         return(tranmodStd(I,#));
    }
}

